<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">

        <title>kidsstuff</title>
        <meta name="description" content="An example webpage.">
        <meta name="author" content="names dont matter">
        <link rel="stylesheet" type="text/css" href="/Webpage/style.css">
        <link rel="icon" href="/Webpage/favicon.svg" type="image/svg+xml">
    </head>
    <body>
        <header>
            <a href="/Webpage/">kidsstuff</a>
        </header>
        <nav>
            <a href="/Webpage/writing/">Writing</a>
            <a href="/Webpage/">About</a>
        </nav>
        <article>
            <h1>Logic and discrete structures</h1>
            <h2>Introduction</h2>
            <p>What does theoretical computer science deal with?</p>
            <ul>
                <li><strong>Algorithmics</strong> deals with the design and analysis of algorithms. An <strong>algorithm</strong> is a set of instructions for solving a problem that is formulated precisely enough to be executed by a computer.</li>
                <li>To solve problems efficiently, not only suitable algorithms are needed, but also the right <strong>data structures</strong> in which to store the data.</li>
                <li><strong>Computability theory</strong> deals with the question of which problems can be solved by computers at all, and <strong>complexity theory</strong> deals with which resources (computing time, memory, etc.) are necessary to solve certain problems.</li>
                <li>One can prove that there is no algorithm that correctly determines for arbitrary programs whether an infinite loop can occur or not. That means, no matter how powerful our computers may be, there will never be a compiler that solves the <strong>halting problem</strong>.</li>
                <li>The traveling salesman problem, like many other easy-to-formulate problems belongs to the class of <strong>NP-hard</strong> problems. It is conjectured that there are no efficient algorithms for these problems. This so-called <strong>P!=NP</strong> conjecture is still unproven and one of the biggest unsolved problems in mathematics and theoretical computer science. Once it has been proven that a problem cannot be solved efficiently, it is clear that the search for an efficient algorithm can be stopped and that alternatives should be considered instead. Moreover, cryptosystems are based on the assumption that certain problems cannot be solved efficiently.</li>
                <li><strong>Automata theory</strong> and <strong>formal languages</strong> form the foundations for programming language design and compiler construction. A formal language is a description of which strings represent valid programs. Normally this description is done by <strong>grammars</strong>. These are systems of rules which describe how syntactically correct programs are generated. The theory of formal languages concerns itself with it, how these rule systems must look, so that a compiler can accomplish the <strong>lexical analysis</strong> and the <strong>syntactical analysis</strong> as efficiently as possible. Lexical analysis is the first step that a compiler performs; it involves breaking down the source code into logically related tokens such as keywords, numbers, and operators. The second step is syntactic analysis, which checks whether the source code is a syntactically correct program and converts the source code into a so-called syntax tree.</li>
                <li><strong>Finite automata</strong> are simple abstract models of computers that are less powerful than conventional computers. Finite automata are used to decide for certain formal languages which words are part of the language and which are not. They are used in compilers for lexical analysis, and they play a role in searching large texts for certain words and patterns.</li>
                <li><strong>Logic</strong> is concerned with how to formally draw conclusions and give proofs. In the simplest form, <strong>propositional logic</strong>, one considers statements that can be true or false. One assumes that one knows of certain elementary statements whether they are true or false, and then studies the truth values of statements that arise from these basic statements through linkages (negation, conjunction, implication, etc.).</li>
                <li>An extension of propositional logic is <strong>first level predicate logic</strong>. An essential aspect of this extension is that quantifiers are allowed in addition to the existing links of propositional logic. Thus, statements of the form "for all x holds..." and "there is an x for which holds..." can be formed.</li>
            </ul>
            <h2>Mathematical basics</h2>
            <h3>Sets</h3>
            <p>A <strong>set</strong> is a collection of objects. If <i>M</i> is a set and if <i>x</i> is an object in this set, we say that <i>x</i> is an element of the set <i>M</i> . Sets consisting of only finitely many elements can be described by the explicit enumeration of their elements. For example, if the set <i>M</i> contains all natural numbers less than 8, we write <i>M</i> = {1, 2, 3, 4, 5, 6, 7}.</p>
            <p>Important sets of numbers:</p>
            <ul>
                <li>Set of <strong>natural numbers</strong>: &#x2115; = {1, 2, 3,...}</li>
                <li>Set of <strong>integers</strong>: &#x2124; = {0, 1, -1, 2, -2, 3, -3,...}</li>
                <li>Set of <strong>rational numbers</strong>: &#x211A;</li>
                <li>Set of <strong>real numbers</strong>: &#x211D;</li>
            </ul>
            <p>If <i>x</i> is an element of the set <i>M</i>, we write <i>x</i> &#8712; <i>M</i>. If <i>x</i> is an object that is not an element of the set <i>M</i>, then we write <i>x</i> &#8713; <i>M</i> .</p>
            <p>We can also define sets by the properties of their elements. If <i>N</i> is a set and <i>A</i> is a property that some elements in <i>N</i> possess, then <br><i>M</i> = {<i>x</i> &#8712; <i>N</i> | <i>x</i> possesses property <i>A</i>}<br> is the set of all elements of <i>N</i> that possess property <i>A</i>.</p>
            <p>We say that a set <i>A</i> is a <strong>subset</strong> of a set <i>B</i> if every element of <i>A</i> is also contained in <i>B</i>. We write this briefly as <i>A</i> ⊆ <i>B</i>. We also call &#x2286; an <strong>inclusion</strong>. If <i>A</i> is a subset of <i>B</i>, we sometimes write <i>B</i> &#x2287; <i>A</i> instead of <i>A</i> ⊆ <i>B</i> and we call <i>B</i> a <strong>superset</strong> of <i>A</i>.</p>
            <p>We say that two sets <i>A</i> and <i>B</i> are <strong>equal</strong> if they contain the same elements, and then write <i>A</i> = <i>B</i>. Moreover, we use &#x2205; as a symbol for the <strong>empty set</strong>, i.e., for the set that contains no element. For each object <i>x</i>, <i>x</i> &#8713; &#x2205; and for each set <i>M</i> holds &#x2205; &#x2286; <i>M</i>.</p>
            <p>Two sets <i>A</i> and <i>B</i> are equal if and only if <i>A</i>  &#x2286; <i>B</i> and <i>B</i> &#x2286; <i>A</i> holds. To show that two sets are equal, it is often the simplest way to prove these two inclusions separately.</p>
            <p>Let <i>M</i> be a set and let <i>A</i> ⊆ <i>M</i> and <i>B</i> ⊆ <i>M</i> be subsets of <i>M</i>. We now define three ways of linking the sets <i>A</i> and <i>B</i>:</p>
            <ul>
                <li>We denote by <i>A</i> ∪ <i>B</i> the <strong>union</strong> of <i>A</i> and <i>B</i>, i.e., <i>A</i> ∪ <i>B</i> = {<i>x</i> ∈ <i>M</i> | <i>x</i> ∈ <i>A</i> or <i>x</i> ∈ <i>B</i>}.</li>
                <li>We denote by <i>A</i> ∩ <i>B</i> the <strong>average</strong> of <i>A</i> and <i>B</i>, i.e., <i>A</i> ∩ <i>B</i> = {<i>x</i> ∈ <i>M</i> | <i>x</i> ∈ <i>A</i> and <i>x</i> ∈ <i>B</i>}.</li>
                <li>We denote by <i>A</i> \ <i>B</i> the <strong>difference</strong> of <i>A</i> and <i>B</i>, i.e., <i>A</i> \ <i>B</i> = {<i>x</i> ∈ <i>M</i> | <i>x</i> ∈ <i>A</i> and <i>x</i> &#8713; <i>B</i>}.</li>
            </ul>
        </article>
    </body>
</html>
